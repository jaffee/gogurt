* Overview

The basic idea here is for me to write a little bit of go code every
day, and then write about what I did. The rules are to do SOMETHING
every day that involves pushing some code to github. If I don't, my
wife gets ten bucks for her clothes shopping fund. If I do, then for
every 7 day streak, I get ten bucks for my 'buy whatever I want'
fund. The purpose is threefold:

1. Learn go.
2. Have consistent github activity.
3. Improve writing and blogging skills.

Hopefully soon, pushing code and posts will automatically update the
site, and I'll have some pretty way to display the code I wrote along
side the post.


** Day 1
Got basic structure set up - mostly looking here:
https://golang.org/doc/code.html

Basic HTTP server running - http://golang.org/doc/articles/wiki/

** Day 2
Today I added some html files, still loosely following the "Writing
Web Applications" page from yesterday.

Go's 'html/template' works by passing a struct to the template's
Execute method which contains fields named the same as the variables
in the template. I haven't played around with what happens if you have
stuff in your struct that isn't in the template or vice versa.

So now I have a root page and another page at '/day/' - goes handlers
seem to do routing by a variant of longest prefix matching, as the '/'
url matches all, but the '/day/' gets used if the URL starts with
/day/ (or just /day interestingly). But if you have handler for
'/day', that will only match '/day'.

After that was going, I started poking around at Github's API - the
idea is going to be to automatically create the page for whatever date
is specified in the URL, i.e. '/day/20150319', by pulling the post and
any commits for the day from Github. Once the day is over, I'll cache
that data in a file so that we don't need to pound github on every
request.

It looks like github's api will be fairly simple - no auth appears to
be necessary, and the URL structure is straightforward. I've got some
ideas for parsing JSON in go based on some things that were said at
the ATX golang meetup, so we'll see how that goes.

** Day 3
Switched gears and did this: [[http://github.com/jaffee/robpike.io]]

** Day 4
Started on =github.go= using net/http to hit the github api, and
encoding/json to read json data into defined type/structs. Not sure
how to read in something like the repos_url which is an array at the
top level... will have to play around with that.
** Day 5
Today I started integrating the github api code with the
website/server code. I had to move github.go into a github directory
in order to make go happy with my package structure, run =go build= on
the github package, then =go run= on gogurt/main.go. But I was able to
import and use functions defined in github.go from main.go, so that's
solid.

I also learned how to loop over slices in templates which used kind of
an odd syntax, but you can see it in =day.html=

I played with the time package quite a bit, getting the current time,
pulling the year, month, and day out of it, and then constructing a
new time with H,M,S set to 0 in order to get the beginning of the day.

I also figured out how to parse JSON into a slice of objects which was
cool.

Tomorrow I'm going to install go auto-complete into emacs so that I
can move a bit faster on silly things like string operations, and then
have my git commits from the previous day displayed on the webpage
(pretty close right now I think).

** Day 6
Set up autocomplete in emacs with company mode and gocode. Seems to
work pretty nicely.

Figured out how to strip the {sha} part of commit urls with
strings.Replace. A little strange to me that strings themselves don't
have methods and you have to use external methods, but I know that's
just a product of too much Python.
** Day 7
Today I was pretty lame - tried breaking up the big getcommits
function, and trying to figure out a way to unmarshal json into the
correct size slice - without having to try to guess the size first.
** Day 8
Wrote a function to pretty print json using json.Indent - then started
reading "effective go".

Also made use of bytes.Buffer - will have to explore bytes lib more.
** Day 9
I've been reading about reflection as I try to figure out how
json.Unmarshal works. I want to figure out how it unmarshals json
arrays into slices so I can figure out how to allocate slices
beforehand. ...and I figured it out - Unmarshal automatically
allocates according to the documentation, so all you have to do is
declare the slice like so

** Day 10
Starting to learn the hard lessons of no generic functions in go (like
'map'). I guess it's not too bad to just write a quick for loop, and
maybe it's worth it for the type safety?

I'm thinking a Post will consist of a title and a some repositories
which I'll hard code for now, and then each repository will be a name
and some commits (all of this is on a per day basis), so each page
will be a list of repos with their commits next to them. Not sure how
I'll work the posts in yet.
#+begin_src go
	var commits_slice []commit
#+end_src

** Day 11
Whew. Big day.
1. Created a new repo which pulls all commits related to a list of
   repos for a day and writes them to a file. (This file will be
   consumed by gogurt is the plan)
2. Wrote my first go test (huge!).
3. Learned a bit about how go's package structure works. It's a bit
   limiting but I guess that's a good thing. This is the reason why I
   ended up splitting the github querying stuff into another repository.
4. Will need to pass a specific header in order to get actual diffs
   per commit - read a bit about how to do this.
5. Learned about Sprintf for easy creation of strings from various
   objects.

Tomorrow I'll either work on getting diffs, or having gogurt read the
files generated by go github.
** Day 12
Took wayyyyy too long, but I got the diffs. I figured out how to send
the header pretty quickly, but wasn't getting diffs back for quite a
while. I tried using wireshark to see if the header was getting dumped
correctly, but then got stymied by the fact that all github api
traffic happens over SSL. A brief tour down "decoding TLS traffic with
wireshark" lane convinced me that it was more trouble than it was
worth (although possible).

I ended up comparing my working curl command with my non working go
code, and realized the URLs were different. Curl was pulling a
specific commit (by sha), whereas I was still trying to pull a bunch
of commits in go. I had to refactor my code to get the list of
commits, and then pull each one separately with the correct header
set, and that worked just dandily.
* Future work ideas
- get code running on some hosting
- set up git hooks to restart it every time there's a push
- write a supervisor in go to restart it if it dies.
