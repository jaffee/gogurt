* Overview

The basic idea here is for me to write a little bit of go code every
day, and then write about what I did. The rules are to do SOMETHING
every day that involves pushing some code to github. If I don't, my
wife gets ten bucks for her clothes shopping fund. If I do, then for
every 7 day streak, I get ten bucks for my 'buy whatever I want'
fund. The purpose is threefold:

1. Learn go.
2. Have consistent github activity.
3. Improve writing and blogging skills.

Hopefully soon, pushing code and posts will automatically update the
site, and I'll have some pretty way to display the code I wrote along
side the post.


** Day 1
Got basic structure set up - mostly looking here:
https://golang.org/doc/code.html

Basic HTTP server running - http://golang.org/doc/articles/wiki/

** Day 2
Today I added some html files, still loosely following the "Writing
Web Applications" page from yesterday.

Go's 'html/template' works by passing a struct to the template's
Execute method which contains fields named the same as the variables
in the template. I haven't played around with what happens if you have
stuff in your struct that isn't in the template or vice versa.

So now I have a root page and another page at '/day/' - goes handlers
seem to do routing by a variant of longest prefix matching, as the '/'
url matches all, but the '/day/' gets used if the URL starts with
/day/ (or just /day interestingly). But if you have handler for
'/day', that will only match '/day'.

After that was going, I started poking around at Github's API - the
idea is going to be to automatically create the page for whatever date
is specified in the URL, i.e. '/day/20150319', by pulling the post and
any commits for the day from Github. Once the day is over, I'll cache
that data in a file so that we don't need to pound github on every
request.

It looks like github's api will be fairly simple - no auth appears to
be necessary, and the URL structure is straightforward. I've got some
ideas for parsing JSON in go based on some things that were said at
the ATX golang meetup, so we'll see how that goes.

** Day 3
Switched gears and did this: [[http://github.com/jaffee/robpike.io]]

** Day 4
Started on =github.go= using net/http to hit the github api, and
encoding/json to read json data into defined type/structs. Not sure
how to read in something like the repos_url which is an array at the
top level... will have to play around with that.
** Day 5
Today I started integrating the github api code with the
website/server code. I had to move github.go into a github directory
in order to make go happy with my package structure, run =go build= on
the github package, then =go run= on gogurt/main.go. But I was able to
import and use functions defined in github.go from main.go, so that's
solid.

I also learned how to loop over slices in templates which used kind of
an odd syntax, but you can see it in =day.html=

I played with the time package quite a bit, getting the current time,
pulling the year, month, and day out of it, and then constructing a
new time with H,M,S set to 0 in order to get the beginning of the day.

I also figured out how to parse JSON into a slice of objects which was
cool.

Tomorrow I'm going to install go auto-complete into emacs so that I
can move a bit faster on silly things like string operations, and then
have my git commits from the previous day displayed on the webpage
(pretty close right now I think).

** Day 6
Set up autocomplete in emacs with company mode and gocode. Seems to
work pretty nicely.

Figured out how to strip the {sha} part of commit urls with
strings.Replace. A little strange to me that strings themselves don't
have methods and you have to use external methods, but I know that's
just a product of too much Python.
** Day 7
Today I was pretty lame - tried breaking up the big getcommits
function, and trying to figure out a way to unmarshal json into the
correct size slice - without having to try to guess the size first.
* Future work ideas
- get code running on some hosting
- set up git hooks to restart it every time there's a push
- write a supervisor in go to restart it if it dies.
